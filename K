#!/usr/bin/env bash
#
# ReInstall Termux Utility — Table UI (Apk | Percentage | Status)
# - Big ASCII banner, orange-red theme, clean table with in-place updates
# - Status flow: Downloading → Downloaded → Installing → Installed → Up to Date (monitor)
# - Main storage: /sdcard/Reinstall (config, logs, apks, rotations)
# - Root/tsu compatible, retries, update detection, Termux:Boot auto-resume
# - Built-in APKs + Custom GitHub Release APKs (Add/Toggle/Remove)
# - File watchers from GitHub raw (json/txt/log) — auto-update
# - Force: Download only or Download + Install (all built-in + selected custom)
# - Logs menu: view, follow, export, clear, diagnostics; rotation
# - Boot & Autostart: Normal (background) and Session (tmux/screen)
#
# Usage:
#   chmod +x reinstall.sh
#   ./reinstall.sh
#   tsu -c ./reinstall.sh
#
set -o nounset
set -o pipefail
set +x 2>/dev/null || true
umask 022

VERSION="2025-08-30-ui12-loop-runner"

# --------- Root/tsu normalization ---------
ROOT_UID="$(id -u 2>/dev/null || echo 0)"
RUNNING_AS_ROOT=0; [ "$ROOT_UID" -eq 0 ] && RUNNING_AS_ROOT=1

TERMUX_PREFIX="/data/data/com.termux/files/usr"
TERMUX_BIN="$TERMUX_PREFIX/bin"
TERMUX_HOME_DEFAULT="/data/data/com.termux/files/home"

case ":${PATH:-}:" in *":$TERMUX_BIN:"*) ;; *) [ -d "$TERMUX_BIN" ] && export PATH="$TERMUX_BIN:$PATH" || true ;; esac
if [ "$RUNNING_AS_ROOT" -eq 1 ] && [ -d "$TERMUX_HOME_DEFAULT" ]; then export HOME="$TERMUX_HOME_DEFAULT"; fi
TMX_HOME="$HOME"

get_home_uid() { stat -c %u "$TMX_HOME" 2>/dev/null || stat -f %u "$TMX_HOME" 2>/dev/null || echo ""; }
get_home_gid() { stat -c %g "$TMX_HOME" 2>/dev/null || stat -f %g "$TMX_HOME" 2>/dev/null || echo ""; }
path_is_private() { case "$1" in "$TMX_HOME"/storage|"$TMX_HOME"/storage/*) return 1;; "$TMX_HOME"|"$TMX_HOME"/*) return 0;; *) return 1;; esac; }
ensure_owner() {
  [ "$RUNNING_AS_ROOT" -eq 1 ] || return 0
  command -v chown >/dev/null 2>&1 || return 0
  local uid gid; uid="$(get_home_uid)"; gid="$(get_home_gid)"
  [ -n "$uid" ] && [ -n "$gid" ] || return 0
  for p in "$@"; do [ -e "$p" ] || continue; if path_is_private "$p"; then chown -R "$uid:$gid" "$p" 2>/dev/null || true; fi; done
}
run_as_root() {
  if [ "$RUNNING_AS_ROOT" -eq 1 ]; then /system/bin/sh -c "$*"
  elif command -v tsu >/dev/null 2>&1; then tsu -c "$*"
  else return 127; fi
}

# --------- Main storage (shared) ---------
ensure_storage_ready() {
  if [ "$RUNNING_AS_ROOT" -eq 0 ]; then
    if [ ! -d "$TMX_HOME/storage/shared" ] && command -v termux-setup-storage >/dev/null 2>&1; then
      termux-setup-storage >/dev/null 2>&1 || true
      for _ in $(seq 1 20); do [ -d "$TMX_HOME/storage/shared" ] && break; sleep 0.2; done
    fi
  fi
}
ensure_storage_ready
get_shared_root() {
  if   [ -d "$TMX_HOME/storage/shared" ]; then echo "$TMX_HOME/storage/shared"
  elif [ -n "${EXTERNAL_STORAGE:-}" ] && [ -d "$EXTERNAL_STORAGE" ]; then echo "$EXTERNAL_STORAGE"
  elif [ -d "/sdcard" ]; then echo "/sdcard"
  elif [ -d "/storage/emulated/0" ]; then echo "/storage/emulated/0"
  else echo "$TMX_HOME/storage/shared"; fi
}
SHARED_ROOT="$(get_shared_root)"
MS_DIR="$SHARED_ROOT/Reinstall"; mkdir -p "$MS_DIR" || true

# --------- Paths / config ---------
APP_DIR="$TMX_HOME/.reinstall"
META_DIR="$APP_DIR/meta"; mkdir -p "$APP_DIR" "$META_DIR" || true
CONFIG_FILE="$MS_DIR/config.json"
CONFIG_TXT="$MS_DIR/selected.txt"
LOG_FILE="$MS_DIR/reinstall.log"
LOG_ARCHIVE_DIR="$MS_DIR/logs"
CUSTOM_APKS_FILE="$MS_DIR/custom_apks.tsv"
WATCHERS_FILE="$MS_DIR/watchers.tsv"
APKS_DIR="$MS_DIR/apks"
TERMUX_BOOT_DIR="$TMX_HOME/.termux/boot"
BOOT_SCRIPT="$TERMUX_BOOT_DIR/reinstall_check.sh"
MONITOR_PID="$APP_DIR/monitor.pid"
MONITOR_INTERVAL_DEFAULT=900
LOOP_RUNNER="$APP_DIR/loop_runner.sh"

mkdir -p "$LOG_ARCHIVE_DIR" "$APKS_DIR" || true

# --------- Logging ---------
LOG_MAX_BYTES=$((1024*1024))
log_rotate_if_needed() {
  [ -f "$LOG_FILE" ] || return 0
  local sz; sz=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || wc -c < "$LOG_FILE" 2>/dev/null || echo 0)
  [ "$sz" -lt "$LOG_MAX_BYTES" ] && return 0
  local stamp="$(( $(date +%s) ))" archived="$LOG_ARCHIVE_DIR/reinstall-$stamp.log"
  mv "$LOG_FILE" "$archived" 2>/dev/null || { cp -f "$LOG_FILE" "$archived" 2>/dev/null || true; : > "$LOG_FILE"; }
  command -v gzip >/dev/null 2>&1 && gzip -f "$archived" >/dev/null 2>&1 || true
}
log()       { mkdir -p "$LOG_ARCHIVE_DIR" || true; log_rotate_if_needed; echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" >> "$LOG_FILE"; }
log_error() { mkdir -p "$LOG_ARCHIVE_DIR" || true; log_rotate_if_needed; echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $*" >> "$LOG_FILE"; }

# --------- Persistence (tmux-aware) ---------
PERSIST_ENV="$APP_DIR/persist.env"
WATCHDOG_SH="$APP_DIR/watchdog.sh"
WATCHDOG_LOG="$MS_DIR/watchdog.log"
BOOT_LOG="$MS_DIR/boot.log"
JOB_ID_WATCHDOG=8723
BOOT_SCRIPT_VERSION="4"
CYCLE_APK_ACTION="${CYCLE_APK_ACTION:-install}"

is_in_tmux() { [ -n "${TMUX:-}" ] && command -v tmux >/dev/null 2>&1; }
tmux_session_name() { tmux display-message -p '#S' 2>/dev/null || echo ""; }

persist_write_env() {
  local sess="$1" interval="$2" action="$3" script_path="$4" boot_mode="${5:-}" session_mgr="${6:-}"
  mkdir -p "$APP_DIR" || true
  [ -z "$boot_mode" ] && { if is_in_tmux; then boot_mode="session"; else boot_mode="normal"; fi; }
  if [ -z "$session_mgr" ]; then
    if command -v tmux >/dev/null 2>&1; then session_mgr="tmux"
    elif command -v screen >/dev/null 2>&1; then session_mgr="screen"
    else session_mgr="none"; fi
  fi
  cat > "$PERSIST_ENV" <<EOF
PERSIST_ENABLED=1
BOOT_MODE=${boot_mode}
SESSION_MGR=${session_mgr}
TMUX_SESSION=${sess}
INTERVAL=${interval}
ACTION=${action}
SCRIPT=${script_path}
USE_TSU=$([ "$RUNNING_AS_ROOT" -eq 1 ] && echo 0 || (command -v tsu >/dev/null 2>&1 && echo 1 || echo 0))
EOF
}

persist_read_env() { [ -f "$PERSIST_ENV" ] && . "$PERSIST_ENV" 2>/dev/null || true; }

persist_disable() {
  if [ -f "$PERSIST_ENV" ]; then
    if grep -q '^PERSIST_ENABLED=' "$PERSIST_ENV" 2>/dev/null; then
      sed -i 's/^PERSIST_ENABLED=.*/PERSIST_ENABLED=0/' "$PERSIST_ENV" 2>/dev/null || true
    else
      echo "PERSIST_ENABLED=0" >> "$PERSIST_ENV"
    fi
  fi
  if command -v termux-job-scheduler >/dev/null 2>&1; then
    termux-job-scheduler --cancel --job-id "$JOB_ID_WATCHDOG" >/dev/null 2>&1 || true
  fi
  log "Persistence disabled"
}

kill_running_monitor() {
  local killed=0
  if [ -f "$MONITOR_PID" ]; then
    local pid; pid="$(cat "$MONITOR_PID" 2>/dev/null || echo)"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then kill "$pid" 2>/dev/null || true; killed=1; fi
  fi
  pkill -f "reinstall.sh.*--monitor" >/dev/null 2>&1 && killed=1 || true
  persist_read_env
  if command -v tmux >/dev/null 2>&1 && tmux has-session -t "${TMUX_SESSION:-reinstall}" >/dev/null 2>&1; then
    tmux kill-session -t "${TMUX_SESSION:-reinstall}" >/dev/null 2>&1 || true
    killed=1
  fi
  if command -v screen >/dev/null 2>&1; then
    if screen -ls 2>/dev/null | grep -q "[[:space:]]\\.${TMUX_SESSION:-reinstall}[[:space:]]"; then
      screen -S "${TMUX_SESSION:-reinstall}" -X quit >/dev/null 2>&1 || true
      killed=1
    fi
  fi
  [ "$killed" -eq 1 ] && log "Killed running monitor(s)"
}

ensure_wakelock() { command -v termux-wake-lock >/dev/null 2>&1 && termux-wake-lock >/dev/null 2>&1 || true; }
release_wakelock() { command -v termux-wake-unlock >/dev/null 2>&1 && termux-wake-unlock >/dev/null 2>&1 || true; }

# --------- Loop runner (avoids ash quoting issues) ---------
ensure_loop_runner() {
  cat > "$LOOP_RUNNER" <<'LR_EOF'
#!/data/data/com.termux/files/usr/bin/bash
set -eu
export HOME=/data/data/com.termux/files/home
export PATH=/data/data/com.termux/files/usr/bin:$PATH

PERSIST_ENV="$HOME/.reinstall/persist.env"
[ -f "$PERSIST_ENV" ] && . "$PERSIST_ENV" || true

SCRIPT="${SCRIPT:-$HOME/.reinstall/reinstall.sh}"
INTERVAL="${INTERVAL:-900}"
ACTION="${ACTION:-install}"

CMD="\"$SCRIPT\" --monitor --interval ${INTERVAL} --no-prompt --replace"
[ "$ACTION" = "download" ] && CMD="$CMD --download-only"

while :; do
  if command -v tsu >/dev/null 2>&1 && [ "${USE_TSU:-0}" -eq 1 ]; then
    tsu -c "$CMD"
  else
    eval "$CMD"
  fi
  echo "restarting in 10s"
  sleep 10
done
LR_EOF
  chmod +x "$LOOP_RUNNER" 2>/dev/null || true
}

generate_watchdog() {
  ensure_loop_runner
  cat > "$WATCHDOG_SH" <<'WD_EOF'
#!/data/data/com.termux/files/usr/bin/bash
set -eu
export HOME=/data/data/com.termux/files/home
export PATH=/data/data/com.termux/files/usr/bin:$PATH

PERSIST_ENV="$HOME/.reinstall/persist.env"
MS_DIR="$( [ -d "$HOME/storage/shared" ] && echo "$HOME/storage/shared" || echo "/sdcard" )/Reinstall"
LOG="$MS_DIR/watchdog.log"
LOOP_RUNNER="$HOME/.reinstall/loop_runner.sh"
mkdir -p "$MS_DIR" >/dev/null 2>&1 || true

echo "$(date '+%F %T') watchdog start" >> "$LOG" 2>&1

[ -f "$PERSIST_ENV" ] || { echo "persist.env missing" >> "$LOG"; exit 0; }
. "$PERSIST_ENV" || { echo "cannot source persist.env" >> "$LOG"; exit 0; }

[ "${PERSIST_ENABLED:-0}" = "1" ] || { echo "persistence disabled" >> "$LOG"; exit 0; }

SCRIPT="${SCRIPT:-$HOME/.reinstall/reinstall.sh}"
INTERVAL="${INTERVAL:-900}"
ACTION="${ACTION:-install}"
TMUX_SESSION="${TMUX_SESSION:-reinstall}"
BOOT_MODE="${BOOT_MODE:-normal}"
SESSION_MGR="${SESSION_MGR:-}"

# Defaults for session manager
if [ -z "$SESSION_MGR" ]; then
  if command -v tmux >/dev/null 2>&1; then SESSION_MGR="tmux"
  elif command -v screen >/dev/null 2>&1; then SESSION_MGR="screen"
  else SESSION_MGR="none"; fi
fi

command -v termux-wake-lock >/dev/null 2>&1 && termux-wake-lock >>"$LOG" 2>&1 || true

if [ "$BOOT_MODE" = "session" ] && [ "$SESSION_MGR" = "tmux" ] && command -v tmux >/dev/null 2>&1; then
  tmux start-server >/dev/null 2>&1 || true
  if ! tmux has-session -t "$TMUX_SESSION" >/dev/null 2>&1; then
    echo "creating tmux session: $TMUX_SESSION" >> "$LOG"
    tmux new-session -d -s "$TMUX_SESSION" "$LOOP_RUNNER" >>"$LOG" 2>&1 || true
  else
    if ! pgrep -f "reinstall.sh.*--monitor" >/dev/null 2>&1; then
      echo "session exists, monitor missing -> respawn window" >> "$LOG"
      tmux new-window -t "$TMUX_SESSION" "$LOOP_RUNNER" >>"$LOG" 2>&1 || true
    fi
  fi
elif [ "$BOOT_MODE" = "session" ] && [ "$SESSION_MGR" = "screen" ] && command -v screen >/dev/null 2>&1; then
  if ! screen -ls 2>/dev/null | grep -q "[[:space:]]\\.${TMUX_SESSION}[[:space:]]"; then
    echo "creating screen session: $TMUX_SESSION" >> "$LOG"
    screen -dmS "$TMUX_SESSION" bash -lc "$LOOP_RUNNER" >>"$LOG" 2>&1 || true
  else
    if ! pgrep -f "reinstall.sh.*--monitor" >/dev/null 2>&1; then
      echo "screen session exists, monitor missing -> new window" >> "$LOG"
      screen -S "$TMUX_SESSION" -X screen bash -lc "$LOOP_RUNNER" >>"$LOG" 2>&1 || true
    fi
  fi
else
  if ! pgrep -f "reinstall.sh.*--monitor" >/dev/null 2>&1; then
    echo "starting detached background monitor" >> "$LOG"
    nohup bash -lc "$LOOP_RUNNER" >>"$LOG" 2>&1 &
  fi
fi

echo "$(date '+%F %T') watchdog done" >> "$LOG" 2>&1
exit 0
WD_EOF
  chmod +x "$WATCHDOG_SH" 2>/dev/null || true
}

ensure_job_scheduler_watchdog() {
  if command -v termux-job-scheduler >/dev/null 2>&1; then
    generate_watchdog
    termux-job-scheduler --job-id "$JOB_ID_WATCHDOG" --script "$WATCHDOG_SH" --period-ms 900000 --persisted true >/dev/null 2>&1 || true
    log "JobScheduler registered watchdog (id=$JOB_ID_WATCHDOG)."
  else
    log "Termux:API not found; watchdog via JobScheduler not registered (boot script still handles reboots)."
  fi
}

persist_enable_if_tmux() {
  persist_read_env
  local sess interval action script_path boot_mode session_mgr
  sess="${TMUX_SESSION:-$(is_in_tmux && tmux_session_name || echo reinstall)}"
  interval="${1:-${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}}"
  action="${2:-${ACTION:-install}}"
  script_path="$(script_self_path)"
  boot_mode="${BOOT_MODE:-}"
  session_mgr="${SESSION_MGR:-}"
  if [ -z "$boot_mode" ]; then
    if is_in_tmux; then boot_mode="session"; else boot_mode="normal"; fi
  fi
  if [ -z "$session_mgr" ]; then
    if command -v tmux >/dev/null 2>&1; then session_mgr="tmux"
    elif command -v screen >/dev/null 2>&1; then session_mgr="screen"
    else session_mgr="none"; fi
  fi
  persist_write_env "$sess" "$interval" "$action" "$script_path" "$boot_mode" "$session_mgr"
  generate_watchdog
  ensure_job_scheduler_watchdog
  log "persistence enabled (mode=$boot_mode, mgr=$session_mgr, session=$sess, interval=$interval, action=$action)."
}

# --------- APK list (built-in) ---------
declare -a APK_URLS=(
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.0.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.1.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.2.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.3.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.4.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.5.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.6.apk"
  "https://github.com/Anrd5/ReInstall/releases/download/V1.0/Cryptic.7.apk"
)
APK_NAMES=( "Cryptic.0.apk" "Cryptic.1.apk" "Cryptic.2.apk" "Cryptic.3.apk" "Cryptic.4.apk" "Cryptic.5.apk" "Cryptic.6.apk" "Cryptic.7.apk" )

# --------- Colors ---------
HAS_TTY=0; [ -t 1 ] && HAS_TTY=1
if [ "$HAS_TTY" -eq 1 ] && command -v tput >/dev/null 2>&1; then
  if tput cols >/dev/null 2>&1 && tput cup 0 0 >/dev/null 2>&1; then :; else HAS_TTY=0; fi
fi
if [ "$HAS_TTY" -eq 1 ]; then
  BOLD=$'\033[1m'; DIM=$'\033[2m'; RESET=$'\033[0m'
  RED=$'\033[1;31m'; GREEN=$'\033[0;32m'; WHITE=$'\033[1;37m'; GRAY=$'\033[38;5;243m'
  ORANGE=$'\033[38;5;208m'; ORANGE2=$'\033[38;5;202m'
else BOLD=''; DIM=''; RESET=''; RED=''; GREEN=''; WHITE=''; GRAY=''; ORANGE=''; ORANGE2=''; fi
CHECK="✓"; CROSS="✗"; ARROW="➜"

# --------- ALT screen + UI helpers ---------
FANCY_UI=0
if [ "$HAS_TTY" -eq 1 ] && command -v tput >/dev/null 2>&1; then
  if tput cols >/dev/null 2>&1 && tput cup 0 0 >/dev/null 2>&1; then FANCY_UI=1; fi
fi
case "${UI_STYLE:-}" in minimal|MINIMAL) FANCY_UI=0;; fancy|FANCY) FANCY_UI=1;; esac

ui_alt_on()  { [ "$HAS_TTY" -eq 1 ] || return 0; (tput smcup 2>/dev/null || printf '\033[?1049h'); printf '\033[2J\033[3J\033[H'; }
ui_alt_off() { [ "$HAS_TTY" -eq 1 ] || return 0; (tput rmcup 2>/dev/null || printf '\033[?1049l'); }
ui_cols()    { tput cols 2>/dev/null || echo 80; }
ui_rows()    { tput lines 2>/dev/null || echo 24; }
ui_hide()    { [ "$FANCY_UI" -eq 1 ] && tput civis 2>/dev/null || true; }
ui_show()    { [ "$FANCY_UI" -eq 1 ] && tput cnorm 2>/dev/null || true; }
ui_goto()    { [ "$FANCY_UI" -eq 1 ] && tput cup "$1" 0 2>/dev/null || true; }

# Safer clear (no terminal reset)
ui_clear() {
  if [ "$FANCY_UI" -eq 1 ]; then
    tput clear 2>/dev/null || printf "\033[2J\033[H"
  else
    printf "\033[2J\033[H"
  fi
}
repeat_char() { local ch="$1" n="$2"; printf "%s" "$(printf "%0.s$ch" $(seq 1 "$n"))"; }

# Fixed ANSI stripper (remove CSI sequences)
ansi_strip() {
  local esc; esc="$(printf '\033')"
  printf "%s" "${1-}" | sed -E "s/${esc}```math
[0-9;?]*[ -/]*[@-~]//g" 2>/dev/null || printf "%s" "${1-}"
}
pad_to() {
  local txt="${1-}" w="${2-0}" plain; plain="$(ansi_strip "$txt")"
  local len="${#plain}"
  if [ "$len" -lt "$w" ]; then
    printf "%s%*s" "$txt" $((w-len)) ""
  else
    printf "%s" "${plain:0:$w}"
  fi
}

# Inline status tracking
STATUS_INLINE=0
ui_status_clear_inline() {
  if [ "${STATUS_INLINE:-0}" -eq 1 ] && [ "$HAS_TTY" -eq 1 ]; then
    printf "\r\033[K"
    STATUS_INLINE=0
  fi
}

# Table layout
UI_ROW0=0; W_NAME=0; W_PCT=0; W_STATUS=0; TOPBAR_ROW=0; BOTTOM_ROW=0; UI_ROWS_COUNT=0
BAR_WIDTH=32

banner() {
  ui_status_clear_inline
  ui_clear
  printf "%s" "$ORANGE"
  cat <<'EOF'
  ___ ___ ___ _  _ ___ _____ _   _    _    
 | _ \ __|_ _| \| / __|_   _/_\ | |  | |   
 |   / _| | || .` \__ \ | |/ _ \| |__| |__ 
 |_|_\___|___|_|\_|___/ |_/_/ \_\____|____|
                                           
EOF
  printf "%s" "$RESET"
  printf "%sTermux • tsu-ready • v%s%s\n\n" "$DIM" "$VERSION" "$RESET"
}

banner_section() {
  local title="$1"
  ui_status_clear_inline
  ui_clear
  printf "%s════════════════════════════════════════%s\n" "$ORANGE2" "$RESET"
  printf "%s          %s%s%s\n" "$ORANGE" "$BOLD" "$title" "$RESET"
  printf "%s════════════════════════════════════════%s\n\n" "$ORANGE2" "$RESET"
}

box_top()    { local cols; cols=$(ui_cols); printf "┌"; repeat_char "─" $((cols-2)); printf "┐\n"; }
box_sep()    { local cols; cols=$(ui_cols); printf "├"; repeat_char "─" $((cols-2)); printf "┤\n"; }
box_bottom() { local cols; cols=$(ui_cols); printf "└"; repeat_char "─" $((cols-2)); printf "┘\n"; }

ui_calc() {
  local cols; cols=$(ui_cols)
  local overhead=10
  local status_min=12
  local name_min=14

  W_PCT=$((BAR_WIDTH + 6))
  local inner=$((cols - overhead))

  if [ $((inner - status_min - name_min)) -lt $((BAR_WIDTH + 6)) ]; then
    local new_bar=$(( inner - status_min - name_min - 6 ))
    [ "$new_bar" -lt 6 ] && new_bar=6
    BAR_WIDTH="$new_bar"
    W_PCT=$((BAR_WIDTH + 6))
  fi

  local rem=$((cols - overhead - W_PCT))
  if [ "$rem" -lt $((name_min + status_min)) ]; then
    W_NAME=$name_min
    W_STATUS=$(( rem - W_NAME )); [ "$W_STATUS" -lt 6 ] && W_STATUS=6
  else
    W_STATUS=$status_min
    W_NAME=$(( rem - W_STATUS ))
  fi

  TOPBAR_ROW=9
  UI_ROW0=$((TOPBAR_ROW + 3))
}

progress_bar() {
  local pct="${1:-0}" barw="$BAR_WIDTH"
  [ "$pct" -gt 100 ] && pct=100; [ "$pct" -lt 0 ] && pct=0
  local fill=$(( (pct * barw + 50) / 100 )); [ "$fill" -gt "$barw" ] && fill="$barw"
  local emp=$(( barw - fill ))
  printf "%s[%s%s]%s %3d%%" "$ORANGE2" "$(printf "%0.s█" $(seq 1 "$fill"))" "$(printf "%0.s·" $(seq 1 "$emp"))" "$RESET" "$pct"
}
progress_bar_unknown() {
  local barw="$BAR_WIDTH" pulse=6
  [ "$pulse" -gt "$barw" ] && pulse="$barw"
  local t rem pre post
  t=$(( ($(date +%s 2>/dev/null || echo 0)) % barw ))
  rem=$(( barw - pulse )); [ "$rem" -le 0 ] && rem=1
  pre=$(( t % rem )); [ "$pre" -lt 0 ] && pre=0
  post=$(( barw - pre - pulse )); [ "$post" -lt 0 ] && post=0
  printf "%s[%s%s%s]%s   --%%" "$ORANGE2" "$(printf "%0.s·" $(seq 1 "$pre"))" "$(printf "%0.s█" $(seq 1 "$pulse"))" "$(printf "%0.s·" $(seq 1 "$post"))" "$RESET"
}

status_colored() {
  case "$1" in
    "Downloading") printf "%sDownloading%s" "$ORANGE2" "$RESET" ;;
    "Downloaded")  printf "%sDownloaded%s"  "$ORANGE"  "$RESET" ;;
    "Installing")  printf "%sInstalling%s"  "$ORANGE2" "$RESET" ;;
    "Installed")   printf "%sInstalled%s"   "$GREEN"   "$RESET" ;;
    "Up to Date")  printf "%sUp to Date%s"  "$GREEN"   "$RESET" ;;
    "Failed")      printf "%sFailed%s"      "$RED"     "$RESET" ;;
    *)             printf "%s" "$1" ;;
  esac
}

ui_header() {
  box_top
  printf "│ %s%-*s%s │ %s%-*s%s │ %s%-*s%s │\n" \
    "$BOLD$WHITE" "$W_NAME" "Apk" "$RESET" \
    "$BOLD$WHITE" "$W_PCT" "Percentage" "$RESET" \
    "$BOLD$WHITE" "$W_STATUS" "Status" "$RESET"
  box_sep
}
ui_row() {
  local row="$1" name="$2" pct_text="$3" status_text="$4"
  local y=$((UI_ROW0 + row))
  if [ "$FANCY_UI" -eq 1 ]; then
    ui_goto "$y"
    printf "\033[K"
    printf "│ %s │ %s │ %s │" \
      "$(pad_to "$name" "$W_NAME")" \
      "$(pad_to "$pct_text" "$W_PCT")" \
      "$(pad_to "$status_text" "$W_STATUS")"
  else
    printf "│ %s │ %s │ %s │\n" \
      "$(pad_to "$name" "$W_NAME")" \
      "$(pad_to "$pct_text" "$W_PCT")" \
      "$(pad_to "$status_text" "$W_STATUS")"
  fi
}
ui_footer() {
  local y=$((UI_ROW0 + UI_ROWS_COUNT))
  if [ "$FANCY_UI" -eq 1 ]; then ui_goto "$y"; fi
  box_bottom
  BOTTOM_ROW=$((y+1))
}
ui_status_line() {
  local msg="$1"
  local cols; cols=$(ui_cols)
  if [ "$FANCY_UI" -eq 1 ]; then
    ui_goto "$BOTTOM_ROW"; printf "\033[K"; ui_goto "$BOTTOM_ROW"; printf "%s" "$msg"
  else
    if [ "$HAS_TTY" -eq 1 ]; then
      local plain; plain="$(ansi_strip "$msg")"
      local max=$((cols - 1)); [ "$max" -lt 1 ] && max=1
      if [ "${#plain}" -gt "$max" ]; then plain="${plain:0:$((max-1))}…"; fi
      printf "\r\033[K%s" "$plain"; STATUS_INLINE=1
    else
      printf "%s\n" "$(ansi_strip "$msg")"
    fi
  fi
}

# --------- HTTP + metadata helpers ---------
get_remote_headers() {
  local url="$1" info=""
  if command -v curl >/dev/null 2>&1; then info=$(curl -fsSIL --retry 2 --connect-timeout 5 --max-time 15 "$url" 2>/dev/null || echo "")
  elif command -v wget >/dev/null 2>&1; then info=$(wget --spider -S --timeout=15 --tries=2 "$url" 2>&1 || echo "")
  else info=""; fi
  echo "$info"
}
parse_header() { local headers="$1" hdr="$2"; echo "$headers" | awk -v h="$hdr" 'BEGIN{IGNORECASE=1; if (substr(h,length(h),1) != ":") h=h ":"} {line=$0; l=tolower(line); hh=tolower(h); if (index(l,hh)==1){idx=index(line, ":"); if (idx>0){val=substr(line, idx+1); gsub(/\r/,"",val); gsub(/^[ \t]+|[ \t]+$/,"",val); print val}}}' | tail -n1; }
get_local_size() { local f="$1"; if [ -f "$f" ]; then stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo 0; else echo 0; fi; }
get_file_hash() { local f="$1"; if [ -f "$f" ]; then if command -v sha256sum >/dev/null 2>&1; then sha256sum "$f" | awk '{print $1}'; elif command -v openssl >/dev/null 2>&1; then openssl dgst -sha256 "$f" | awk '{print $2}'; else echo "unavailable"; fi else echo "missing"; fi; }
meta_file() { echo "$META_DIR/${1}.meta"; }
meta_get() { local entry="$1" key="$2" file; file=$(meta_file "$entry"); [ -f "$file" ] || { echo ""; return 0; }; grep -E "^${key}=" "$file" 2>/dev/null | head -n1 | cut -d'=' -f2- || echo ""; }
meta_put() {
  local entry="$1" key="$2" value="$3" file; file=$(meta_file "$entry")
  mkdir -p "$META_DIR"; touch "$file"
  if grep -qE "^${key}=" "$file"; then
    sed -i "s|^${key}=.*|${key}=${value}|" "$file" 2>/dev/null || {
      local tmp; tmp=$(mktemp 2>/dev/null || echo "$file.tmp")
      sed "s|^${key}=.*|${key}=${value}|" "$file" > "$tmp" && mv "$tmp" "$file"
    }
  else printf "%s=%s\n" "$key" "$value" >> "$file"; fi
}

check_for_update_apk() {
  local apkname url local_file
  apkname="${1-}"; url="${2-}"; local_file="$APKS_DIR/${apkname-}"
  [ -f "$local_file" ] || return 0
  local headers remote_len remote_etag remote_mod local_len meta_etag meta_mod
  headers="$(get_remote_headers "$url")"; [ -z "$headers" ] && return 1
  remote_len="$(parse_header "$headers" "Content-Length")"
  remote_etag="$(parse_header "$headers" "ETag")"
  remote_mod="$(parse_header "$headers" "Last-Modified")"
  local_len="$(get_local_size "$local_file")"
  meta_etag="$(meta_get "$apkname" "etag")"
  meta_mod="$(meta_get "$apkname" "last_modified")"
  if [ -n "${remote_len:-}" ] && [ "$remote_len" != "$local_len" ]; then return 0; fi
  if [ -n "${remote_etag:-}" ] && [ "$remote_etag" != "${meta_etag:-}" ]; then return 0; fi
  if [ -n "${remote_mod:-}" ] && [ "$remote_mod" != "${meta_mod:-}" ]; then return 0; fi
  return 1
}
save_fresh_metadata_generic() {
  local meta_key="${1-}" url="${2-}" local_file="${3-}"
  local headers len etag lmod hash; headers="$(get_remote_headers "$url")"; len="$(parse_header "$headers" "Content-Length")"; etag="$(parse_header "$headers" "ETag")"; lmod="$(parse_header "$headers" "Last-Modified")"; hash="$(get_file_hash "$local_file")"
  [ -n "$len" ] || len="$(get_local_size "$local_file")"
  meta_put "$meta_key" "size" "$len"; [ -n "$etag" ] && meta_put "$meta_key" "etag" "$etag" || true; [ -n "$lmod" ] && meta_put "$meta_key" "last_modified" "$lmod" || true; meta_put "$meta_key" "sha256" "$hash"; meta_put "$meta_key" "checked_at" "$(date -Iseconds)"
}

# --------- Downloader ---------
download_into_row() {
  local row="$1" label="$2" url="$3" out="$4"
  local tmp="$out.part" headers remote_len dl_pid status

  headers="$(get_remote_headers "$url")"
  remote_len="$(parse_header "$headers" "Content-Length")"
  [ -z "$remote_len" ] && remote_len=0

  ui_row "$row" "$label" "$(progress_bar 0)" "$(status_colored "Downloading")"

  local attempt=1 max_attempts=3
  while [ "$attempt" -le "$max_attempts" ]; do
    if command -v curl >/dev/null 2>&1; then
      if [ -f "$tmp" ]; then
        curl -fsSL --retry 2 --connect-timeout 5 --max-time 0 -C - -o "$tmp" "$url" >/dev/null 2>&1 &
      else
        curl -fsSL --retry 2 --connect-timeout 5 --max-time 0 -o "$tmp" "$url" >/dev/null 2>&1 &
      fi
    elif command -v wget >/dev/null 2>&1; then
      if [ -f "$tmp" ]; then wget -q --continue -O "$tmp" "$url" >/dev/null 2>&1 &
      else wget -q -O "$tmp" "$url" >/dev/null 2>&1 & fi
    else
      ui_row "$row" "$label" "   --%" "$(status_colored "Failed")"
      return 127
    fi
    dl_pid=$^

    # In case bash ^ expansion is not desired; set correctly:
    dl_pid=$!

    if [ "$remote_len" -gt 0 ]; then
      local pct=0
      while kill -0 "$dl_pid" 2>/dev/null; do
        local sz; sz=$(get_local_size "$tmp")
        if [ "$sz" -gt 0 ]; then pct=$(( sz * 100 / remote_len )); [ "$pct" -gt 100 ] && pct=100; else pct=0; fi
        ui_row "$row" "$label" "$(progress_bar "$pct")" "$(status_colored "Downloading")"
        sleep 0.15
      done
    else
      while kill -0 "$dl_pid" 2>/dev/null; do
        ui_row "$row" "$label" "$(progress_bar_unknown)" "$(status_colored "Downloading")"
        sleep 0.15
      done
    fi

    if wait "$dl_pid"; then
      mv -f "$tmp" "$out" 2>/dev/null || { cp -f "$tmp" "$out" 2>/dev/null || true; rm -f "$tmp" 2>/dev/null || true; }
      ui_row "$row" "$label" "$(progress_bar 100)" "$(status_colored "Downloaded")"
      return 0
    fi
    ui_row "$row" "$label" "retry $attempt/$max_attempts" "$(status_colored "Failed")"
    attempt=$((attempt+1)); sleep 0.7
  done

  rm -f "$tmp" 2>/dev/null || true
  ui_row "$row" "$label" "   --%" "$(status_colored "Failed")"
  return 1
}

# --------- Install helpers ---------
install_apk_root_ways() {
  local apkfile="$1"
  if run_as_root "pm install -r --user 0 \"$apkfile\" >/dev/null 2>&1"; then return 0; fi
  if run_as_root "pm install -r \"$apkfile\" >/dev/null 2>&1"; then return 0; fi
  if run_as_root "cmd package install -r \"$apkfile\" >/dev/null 2>&1"; then return 0; fi
  if run_as_root "/system/bin/sh -c 'pm install -r \"$apkfile\"' >/dev/null 2>&1"; then return 0; fi
  return 1
}
install_apk_interactive() {
  local apkfile="$1"
  if command -v termux-open >/dev/null 2>&1; then termux-open "$apkfile" >/dev/null 2>&1 && return 0; fi
  if command -v am >/dev/null 2>&1; then am start -a android.intent.action.VIEW -d "file://$apkfile" -t "application/vnd.android.package-archive" >/dev/null 2>&1 && return 0; fi
  return 1
}
install_row() {
  local row="$1" label="$2" file="$3"
  ui_row "$row" "$label" "$(progress_bar 100)" "$(status_colored "Installing")"
  if install_apk_root_ways "$file"; then
    ui_row "$row" "$label" "$(progress_bar 100)" "$(status_colored "Installed")"
    echo "root_ok"; return 0
  fi
  if install_apk_interactive "$file"; then
    ui_row "$row" "$label" "$(progress_bar 100)" "$(status_colored "Installing")"
    echo "interactive"; return 2
  fi
  ui_row "$row" "$label" "$(progress_bar 100)" "$(status_colored "Failed")"
  echo "failed"; return 1
}

# --------- Publish to Downloads ---------
publish_to_downloads_root() {
  local src="$1" dlroot="$TMX_HOME/storage/downloads"
  [ -f "$src" ] || return 0; [ -d "$dlroot" ] || return 0
  local base dest; base="$(basename "$src")"; dest="$dlroot/$base"
  if [ "$src" != "$dest" ]; then cp -f "$src" "$dest" 2>/dev/null || true; fi
  command -v termux-media-scan >/dev/null 2>&1 && termux-media-scan "$dest" >/dev/null 2>&1 || true
  command -v am >/dev/null 2>&1 && am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FILE -d "file://$dest" >/dev/null 2>&1 || true
  log "Published to Downloads: $dest"
}

# --------- Small helpers ---------
trim() { local x="${1:-}"; x="${x#"${x%%[![:space:]]*}"}"; x="${x%"${x##*[![:space:]]}"}"; printf '%s' "$x"; }
str_sha1() { local s="$1"; if command -v sha1sum >/dev/null 2>&1; then printf '%s' "$s" | sha1sum | awk '{print $1}'; elif command -v openssl >/dev/null 2>&1; then printf '%s' "$s" | openssl sha1 | awk '{print $2}'; else local sum=0 i ch; for ((i=0;i<${#s};i++)); do ch=$(printf '%d' "'${s:i:1}"); sum=$(( (sum + ch) % 1000000007 )); done; printf 's%08d' "$sum"; fi; }

# --------- Config read/write ---------
write_config() {
  local -n sel_indices=$1
  mkdir -p "$MS_DIR" || true
  { echo "{ \"selected\": ["; local first=1; for i in "${sel_indices[@]}"; do if [ $first -eq 1 ]; then printf '  %d' "$i"; first=0; else printf ', %d' "$i"; fi; done; echo ""; echo "]}" ; } > "$CONFIG_FILE"
  : > "$CONFIG_TXT"; for i in "${sel_indices[@]}"; do printf '%s\n' "$i" >> "$CONFIG_TXT"; done
}
read_config() {
  if [ -f "$CONFIG_TXT" ]; then local out=() line; while IFS= read -r line; do case "$line" in ''|*[!0-9]* ) ;; * ) out+=("$line");; esac; done < "$CONFIG_TXT"; [ "${#out[@]}" -gt 0 ] && { echo "${out[@]}"; return; }; fi
  if [ -f "$CONFIG_FILE" ] && command -v jq >/dev/null 2>&1; then mapfile -t arr < <(jq -r '.selected[]?' "$CONFIG_FILE" 2>/dev/null || true); [ "${#arr[@]}" -gt 0 ] && { echo "${arr[@]}"; return; }; fi
  echo ""
}

# --------- Custom APKs ---------
ensure_custom_file() { [ -f "$CUSTOM_APKS_FILE" ] || { : > "$CUSTOM_APKS_FILE"; }; }
custom_apks_selected_lines() { ensure_custom_file; awk -F'\t' 'NF>=3 && $3=="1"{print}' "$CUSTOM_APKS_FILE" 2>/dev/null || true; }
custom_apks_add() { ensure_custom_file; local apkname_in url sel apkname_val; apkname_in="$(trim "${1-}")"; url="$(trim "${2-}")"; sel="${3:-1}"; apkname_val="$apkname_in"; [ -z "$apkname_val" ] && apkname_val="$(basename "$url" 2>/dev/null || echo "custom.apk")"; printf "%s\t%s\t%s\n" "$apkname_val" "$url" "$sel" >> "$CUSTOM_APKS_FILE"; }
custom_apks_toggle() { ensure_custom_file; local line="$1" tmp; tmp=$(mktemp 2>/dev/null || echo "$CUSTOM_APKS_FILE.tmp"); awk -v ln="$line" -F'\t' 'BEGIN{OFS="\t"} NR==ln && NF>=3 { $3=($3=="1"?"0":"1"); print; next } {print}' "$CUSTOM_APKS_FILE" > "$tmp"; mv "$tmp" "$CUSTOM_APKS_FILE"; }
custom_apks_remove() { local line="$1" tmp; tmp=$(mktemp 2>/dev/null || echo "$CUSTOM_APKS_FILE.tmp"); awk -v ln="$line" 'NR!=ln{print}' "$CUSTOM_APKS_FILE" > "$tmp"; mv "$tmp" "$CUSTOM_APKS_FILE"; }
build_github_release_url() { printf "https://github.com/%s/%s/releases/download/%s/%s" "$1" "$2" "$3" "$4"; }

# --------- Watchers ---------
ensure_watchers_file() { [ -f "$WATCHERS_FILE" ] || { : > "$WATCHERS_FILE"; }; }
watchers_list_all() { ensure_watchers_file; cat "$WATCHERS_FILE" 2>/dev/null || true; }
watchers_add() { ensure_watchers_file; printf "%s\t%s\t%s\n" "$1" "$2" "${3:-1}" >> "$WATCHERS_FILE"; }
watchers_toggle() { local line="$1" tmp; tmp=$(mktemp 2>/dev/null || echo "$WATCHERS_FILE.tmp"); awk -v ln="$line" -F'\t' 'BEGIN{OFS="\t"} NR==ln && NF>=3 { $3=($3=="1"?"0":"1"); print; next } {print}' "$WATCHERS_FILE" > "$tmp"; mv "$tmp" "$WATCHERS_FILE"; }
watchers_remove() { local line="$1" tmp; tmp=$(mktemp 2>/dev/null || echo "$WATCHERS_FILE.tmp"); awk -v ln="$line" 'NR!=ln{print}' "$WATCHERS_FILE" > "$tmp"; mv "$tmp" "$WATCHERS_FILE"; }
watcher_meta_key() { local h; h=$(str_sha1 "$1|$2"); printf "watch-%s" "$h"; }
watcher_needs_update() {
  local tgt="$1" url="$2" meta; meta="$(watcher_meta_key "$tgt" "$url")"
  local headers remote_len remote_etag remote_mod meta_etag meta_mod
  headers="$(get_remote_headers "$url")"; [ -z "$headers" ] && return 2
  remote_len="$(parse_header "$headers" "Content-Length")"
  remote_etag="$(parse_header "$headers" "ETag")"
  remote_mod="$(parse_header "$headers" "Last-Modified")"
  meta_etag="$(meta_get "$meta" "etag")"
  meta_mod="$(meta_get "$meta" "last_modified")"
  [ -f "$tgt" ] || return 0
  if [ -n "${remote_etag:-}" ] && [ "$remote_etag" != "${meta_etag:-}" ]; then return 0; fi
  if [ -n "${remote_mod:-}" ] && [ "$remote_mod" != "${meta_mod:-}" ]; then return 0; fi
  if [ -n "${remote_len:-}" ]; then local lsz; lsz="$(get_local_size "$tgt")"; [ "$lsz" -ne "${remote_len:-0}" ] && return 0; fi
  return 1
}

# --------- Termux:Boot (auto) ---------
check_termux_boot() { command -v pm >/dev/null 2>&1 && pm list packages 2>/dev/null | grep -q "com.termux.boot"; }
script_self_path() { local src="${BASH_SOURCE[0]:-$0}"; if command -v realpath >/dev/null 2>&1; then realpath "$src"; elif command -v readlink >/dev/null 2>&1; then readlink -f "$src" 2>/dev/null || echo "$src"; else echo "$src"; fi; }
ensure_self_installed() { local self; self="$(script_self_path)"; local target="$APP_DIR/reinstall.sh"; if [ "$self" != "$target" ]; then cp -f "$self" "$target" 2>/dev/null || true; chmod +x "$target" 2>/dev/null || true; ensure_owner "$target"; fi; }

auto_setup_termux_boot() {
  check_termux_boot || return 0
  mkdir -p "$TERMUX_BOOT_DIR" || true
  local need_write=0
  if [ ! -f "$BOOT_SCRIPT" ]; then
    need_write=1
  else
    grep -q "REINSTALL_BOOT_V=$BOOT_SCRIPT_VERSION" "$BOOT_SCRIPT" 2>/dev/null || need_write=1
  fi
  [ "$need_write" -eq 0 ] && return 0

  ensure_loop_runner

  cat > "$BOOT_SCRIPT" <<BOOT_EOF
#!/data/data/com.termux/files/usr/bin/bash
# REINSTALL_BOOT_V=$BOOT_SCRIPT_VERSION
set -eu
export HOME=/data/data/com.termux/files/home
export PATH=/data/data/com.termux/files/usr/bin:\$PATH

sleep 10

if   [ -d "\$HOME/storage/shared" ]; then SHARED_ROOT="\$HOME/storage/shared"
elif [ -n "\$EXTERNAL_STORAGE" ] && [ -d "\$EXTERNAL_STORAGE" ]; then SHARED_ROOT="\$EXTERNAL_STORAGE"
elif [ -d "/sdcard" ]; then SHARED_ROOT="/sdcard"
else SHARED_ROOT="/storage/emulated/0"; fi
MS_DIR="\$SHARED_ROOT/Reinstall"; mkdir -p "\$MS_DIR" >/dev/null 2>&1 || true
BOOT_LOG="\$MS_DIR/boot.log"

PERSIST_ENV="\$HOME/.reinstall/persist.env"
WATCHDOG_SH="\$HOME/.reinstall/watchdog.sh"
LOOP_RUNNER="\$HOME/.reinstall/loop_runner.sh"

[ -f "\$PERSIST_ENV" ] || { echo "no persist.env - nothing to start" >> "\$BOOT_LOG"; exit 0; }
. "\$PERSIST_ENV" || { echo "cannot source persist.env" >> "\$BOOT_LOG"; exit 0; }

[ "\${PERSIST_ENABLED:-0}" = "1" ] || { echo "persistence disabled" >> "\$BOOT_LOG"; exit 0; }

SCRIPT_CAND=("\$HOME/.reinstall/reinstall.sh" "\$HOME/reinstall.sh")
[ -n "\$SCRIPT" ] || {
  for s in "\${SCRIPT_CAND[@]}"; do [ -x "\$s" ] && SCRIPT="\$s" && break; done
}
[ -x "\$SCRIPT" ] || { echo "no reinstall.sh executable" >> "\$BOOT_LOG"; exit 0; }

[ -n "\$INTERVAL" ] || INTERVAL=900
[ -n "\$ACTION" ] || ACTION="install"
[ -n "\$TMUX_SESSION" ] || TMUX_SESSION="reinstall"
[ -n "\$BOOT_MODE" ] || BOOT_MODE="normal"
[ -n "\$SESSION_MGR" ] || SESSION_MGR=""

if [ -z "\$SESSION_MGR" ]; then
  if command -v tmux >/dev/null 2>&1; then SESSION_MGR="tmux"
  elif command -v screen >/dev/null 2>&1; then SESSION_MGR="screen"
  else SESSION_MGR="none"; fi
fi

CMD="\"\$SCRIPT\" --monitor --interval \$INTERVAL --no-prompt --replace"
[ "\$ACTION" = "download" ] && CMD="\$CMD --download-only"

command -v termux-wake-lock >/dev/null 2>&1 && termux-wake-lock >>"\$BOOT_LOG" 2>&1 || true

if [ "\$BOOT_MODE" = "session" ] && [ "\$SESSION_MGR" = "tmux" ] && command -v tmux >/dev/null 2>&1; then
  tmux start-server >/dev/null 2>&1 || true
  if ! tmux has-session -t "\$TMUX_SESSION" >/dev/null 2>&1; then
    echo "Boot: starting tmux session '\$TMUX_SESSION'" >> "\$BOOT_LOG" 2>&1
    if [ -x "\$LOOP_RUNNER" ]; then
      tmux new-session -d -s "\$TMUX_SESSION" "\$LOOP_RUNNER" >>"\$BOOT_LOG" 2>&1 || true
    else
      tmux new-session -d -s "\$TMUX_SESSION" "bash -lc 'while :; do eval \$CMD; echo restarting in 10s; sleep 10; done'" >>"\$BOOT_LOG" 2>&1 || true
    fi
  else
    echo "Boot: tmux session '\$TMUX_SESSION' already exists" >> "\$BOOT_LOG"
  fi
elif [ "\$BOOT_MODE" = "session" ] && [ "\$SESSION_MGR" = "screen" ] && command -v screen >/dev/null 2>&1; then
  if ! screen -ls 2>/dev/null | grep -q "[[:space:]]\\.\$TMUX_SESSION[[:space:]]"; then
    echo "Boot: starting screen session '\$TMUX_SESSION'" >> "\$BOOT_LOG"
    if [ -x "\$LOOP_RUNNER" ]; then
      screen -dmS "\$TMUX_SESSION" bash -lc "\$LOOP_RUNNER" >> "\$BOOT_LOG" 2>&1 || true
    else
      screen -dmS "\$TMUX_SESSION" bash -lc "while :; do eval \$CMD; echo 'restarting in 10s'; sleep 10; done" >> "\$BOOT_LOG" 2>&1 || true
    fi
  else
    echo "Boot: screen session '\$TMUX_SESSION' already exists" >> "\$BOOT_LOG"
  fi
else
  echo "Boot: starting detached background monitor" >> "\$BOOT_LOG"
  if [ -x "\$LOOP_RUNNER" ]; then
    nohup bash -lc "\$LOOP_RUNNER" >> "\$BOOT_LOG" 2>&1 &
  else
    nohup bash -lc "while :; do eval \$CMD; echo 'restarting in 10s'; sleep 10; done" >> "\$BOOT_LOG" 2>&1 &
  fi
fi

if command -v termux-job-scheduler >/dev/null 2>&1 && [ -x "\$WATCHDOG_SH" ]; then
  termux-job-scheduler --job-id $JOB_ID_WATCHDOG --script "\$WATCHDOG_SH" --period-ms 900000 --persisted true >> "\$BOOT_LOG" 2>&1 || true
fi

exit 0
BOOT_EOF
  chmod +x "$BOOT_SCRIPT" 2>/dev/null || true
}

# --------- Selection UI ---------
setup_reinstall() {
  enter_ui
  ui_hide
  banner_section "SETUP APK SELECTION"
  printf "%s%sAvailable APKs:%s\n\n" "$BOLD" "$WHITE" "$RESET"
  local n
  for idx in "${!APK_URLS[@]}"; do 
    n=$((idx+1))
    printf "  %s[%d]%s %s%s%s\n" "$ORANGE" "$n" "$RESET" "$WHITE" "${APK_NAMES[$idx]}" "$RESET"
  done
  printf "\n%s────────────────────────────────────────%s\n" "$GRAY" "$RESET"
  printf "\n%sEnter numbers/ranges (e.g. 1-3 5 7)\nType 'all' for all APKs or '0' for none%s\n\n" "$DIM" "$RESET"
  printf "%s%s Selection:%s " "$ORANGE" "$ARROW" "$RESET"
  read -r selection_line
  parse_tokens_to_indices() {
    local line="$1" max="${#APK_URLS[@]}" out=() token a b j; declare -A seen=()
    if [[ "$line" =~ ^[Aa][Ll][Ll]$ ]]; then for i in $(seq 1 "$max"); do out+=("$((i-1))"); done
    else for token in $line; do
      if [[ "$token" =~ ^[0-9]+-[0-9]+$ ]]; then a=${token%-*}; b=${token#*-}; [ "$a" -gt "$b" ] && { local t="$a"; a="$b"; b="$t"; }; [ "$a" -lt 1 ] && a=1; [ "$b" -gt "$max" ] && b="$max"; for j in $(seq "$a" "$b"); do [ -z "${seen[$j]:-}" ] && { out+=("$((j-1))"); seen[$j]=1; }; done
      elif [[ "$token" =~ ^[0-9]+$ ]]; then [ "$token" -eq 0 ] && { out=(); break; }; if [ "$token" -ge 1 ] && [ "$token" -le "$max" ]; then [ -z "${seen[$token]:-}" ] && { out+=("$((token-1))"); seen[$token]=1; }; fi
      fi
    done; fi
    echo "${out[@]}"
  }
  IFS=' ' read -r -a chosen <<< "$(parse_tokens_to_indices "$selection_line")"
  write_config chosen
  echo
  printf "%s%s✓ Configuration saved%s\n" "$GREEN" "$BOLD" "$RESET"
  printf "%sSelected: %d APKs%s\n" "$DIM" "${#chosen[@]}" "$RESET"
  printf "%sAPK directory: %s%s\n\n" "$DIM" "$APKS_DIR" "$RESET"
  read -r -p "Press Enter to continue..." _
  ui_show
}

# --------- Build rows ---------
build_rows() {
  local action="${1:-install}"
  IFS=' ' read -r -a sel_builtin <<< "$(read_config)"
  mapfile -t sel_custom < <(custom_apks_selected_lines || true)
  mapfile -t watchers_all < <(watchers_list_all || true)

  row_names=(); row_urls=(); row_outs=(); row_kinds=(); row_actions=(); row_need=()

  for idx in "${sel_builtin[@]}"; do
    local name="${APK_NAMES[$idx]:-}" url="${APK_URLS[$idx]:-}"
    [ -n "$name" ] && [ -n "$url" ] || continue
    row_names+=("$name"); row_urls+=("$url"); row_outs+=("$APKS_DIR/$name"); row_kinds+=("APK"); row_actions+=("$action")
    if check_for_update_apk "$name" "$url"; then row_need+=(1); else row_need+=(0); fi
  done
  for line in "${sel_custom[@]}"; do
    [ -z "$line" ] && continue
    IFS=$'\t' read -r cname curl csel <<< "$line"; [ "${csel:-0}" = "1" ] || continue
    [ -n "${cname:-}" ] || cname="$(basename "$curl" 2>/dev/null || echo "custom.apk")"
    row_names+=("$cname"); row_urls+=("$curl"); row_outs+=("$APKS_DIR/$cname"); row_kinds+=("APK"); row_actions+=("$action")
    if check_for_update_apk "$cname" "$curl"; then row_need+=(1); else row_need+=(0); fi
  done
  for wline in "${watchers_all[@]}"; do
    [ -z "$wline" ] && continue
    IFS=$'\t' read -r wtgt wurl wen <<< "$wline"; [ "${wen:-0}" = "1" ] || continue
    row_names+=("$wtgt"); row_urls+=("$wurl"); row_outs+=("$wtgt"); row_kinds+=("FILE"); row_actions+=("write")
    if watcher_needs_update "$wtgt" "$wurl"; then row_need+=(1); else row_need+=(0); fi
  done
}

# --------- Process table once ---------
process_table_once() {
  enter_ui
  local action="${1:-install}"
  build_rows "$action"
  UI_ROWS_COUNT=${#row_names[@]}

  ui_hide; banner; ui_calc; ui_header
  if [ "$UI_ROWS_COUNT" -eq 0 ]; then
    printf "│ %s │ %s │ %s │\n" "$(pad_to "(nothing configured)" "$W_NAME")" "$(pad_to "--" "$W_PCT")" "$(pad_to "--" "$W_STATUS")"
    ui_footer; ui_show
    return 0
  fi

  local i
  for i in $(seq 0 $((UI_ROWS_COUNT-1))); do
    local name="${row_names[$i]}"
    local pct_txt="   --%"
    local status_txt="$(status_colored "$([ "${row_need[$i]}" = "1" ] && echo "Downloading" || echo "Up to Date")")"
    if [ "${row_need[$i]}" = "0" ]; then pct_txt="$(progress_bar 100)"; status_txt="$(status_colored "Up to Date")"; fi
    ui_row "$i" "$name" "$pct_txt" "$status_txt"
  done
  ui_footer

  local succ=0 fail=0 launched=0 res
  for i in $(seq 0 $((UI_ROWS_COUNT-1))); do
    [ "${row_need[$i]}" = "1" ] || continue
    local name="${row_names[$i]}" url="${row_urls[$i]}" out="${row_outs[$i]}" kind="${row_kinds[$i]}" act="${row_actions[$i]}"

    if download_into_row "$i" "$name" "$url" "$out"; then
      save_fresh_metadata_generic "$(basename "$out")" "$url" "$out"
      if [ "$kind" = "APK" ] && [ "$act" = "install" ]; then
        res="$(install_row "$i" "$name" "$out")" || true
        case "$res" in
          root_ok)     succ=$((succ+1)) ;;
          interactive) launched=$((launched+1)) ;;
          *)           fail=$((fail+1)) ;;
        esac
      else
        ui_row "$i" "$name" "$(progress_bar 100)" "$(status_colored "Downloaded")"
        succ=$((succ+1))
      fi
    else
      ui_row "$i" "$name" "   --%" "$(status_colored "Failed")"
      fail=$((fail+1))
    fi
  done

  ui_status_line "$(printf "%sDone.%s Success: %d  Launched: %d  Fail: %d" "$DIM" "$RESET" "$succ" "$launched" "$fail")"
  ui_show
}

# --------- Monitor mode ---------
ensure_single_monitor() {
  local mode="${1:-ask}" # ask|replace|keep
  if [ -f "$MONITOR_PID" ]; then
    local oldpid; oldpid="$(cat "$MONITOR_PID" 2>/dev/null || echo "")"
    if [ -n "$oldpid" ] && kill -0 "$oldpid" 2>/dev/null; then
      case "$mode" in
        replace) kill "$oldpid" 2>/dev/null || true; sleep 0.3 ;;
        keep)    return 2 ;;
        ask)
          banner
          echo "Another monitor is running (PID $oldpid)."
          read -r -p "Replace it? (Y/n): " ans
          [[ "$ans" =~ ^[Nn]$ ]] && return 2
          kill "$oldpid" 2>/dev/null || true; sleep 0.3 ;;
      esac
    else rm -f "$MONITOR_PID" 2>/dev/null || true; fi
  fi
  echo "$$" > "$MONITOR_PID"
  return 0
}
monitor_loop() {
  local interval="${1:-$MONITOR_INTERVAL_DEFAULT}" replace="${2:-ask}"
  local action="${CYCLE_APK_ACTION:-install}"

  ensure_single_monitor "$replace" || { ui_status_line "Monitor already running; keeping existing."; sleep 1; return 0; }

  persist_enable_if_tmux "$interval" "$action"
  ensure_wakelock

  enter_ui
  ui_hide
  local STOP=0
  trap 'STOP=1' INT TERM
  while [ "$STOP" -eq 0 ]; do
    process_table_once "$action"
    log "Cycle complete."
    local t
    for t in $(seq "$interval" -1 1); do
      [ "$STOP" -ne 0 ] && break
      ui_status_line "$(printf "%sNext check in %ds — Ctrl+C to stop%s" "$DIM" "$t" "$RESET")"
      sleep 1
    done
  done
  trap - INT TERM
  rm -f "$MONITOR_PID" 2>/dev/null || true
  release_wakelock
  if [ "${STATUS_INLINE:-0}" -eq 1 ]; then printf "\n"; STATUS_INLINE=0; fi
  ui_show
}

start_monitor_from_menu() {
  enter_ui
  banner_section "CONTINUOUS MONITORING"
  printf "%s• Automatically checks and installs APKs%s\n" "$WHITE" "$RESET"
  printf "%s• Updates watched configuration files%s\n" "$WHITE" "$RESET"
  printf "%s• Runs continuously (stop with Ctrl+C)%s\n\n" "$WHITE" "$RESET"
  printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
  read -r -p "${ORANGE}${ARROW}${RESET} Start monitoring? (y/N): " ans
  [[ "$ans" =~ ^[Yy]$ ]] || return 0
  monitor_loop "$MONITOR_INTERVAL_DEFAULT" "ask"
}

# --------- Force actions ---------
force_prompt_and_run() {
  enter_ui
  banner_section "FORCE DOWNLOAD/REINSTALL"
  printf "%sSelect action mode:%s\n\n" "$WHITE" "$RESET"
  printf "  %s1)%s Download + Install\n" "$ORANGE" "$RESET"
  printf "  %s2)%s Download only %s(default)%s\n\n" "$ORANGE" "$RESET" "$DIM" "$RESET"
  read -r -p "${ORANGE}${ARROW}${RESET} Mode [1/2]: " m
  local mode="download"; [ "${m:-2}" = "1" ] && mode="install"
  process_table_once "$mode"
}

# --------- Settings ---------
settings_menu() {
  enter_ui
  banner_section "SETTINGS"
  printf "%s%sConfiguration:%s\n\n" "$BOLD" "$WHITE" "$RESET"
  printf "  %sAPK directory:%s %s\n" "$GRAY" "$RESET" "$APKS_DIR"
  printf "  %sMain storage:%s  %s\n" "$GRAY" "$RESET" "$MS_DIR"
  printf "  %sLog file:%s      %s\n" "$GRAY" "$RESET" "$LOG_FILE"
  printf "  %sUI style:%s      %s\n\n" "$GRAY" "$RESET" "$([ "$FANCY_UI" -eq 1 ] && echo "Fancy" || echo "Minimal")"
  printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
  printf "  %s1)%s Change APK directory\n" "$ORANGE" "$RESET"
  printf "  %s2)%s Toggle UI style\n" "$ORANGE" "$RESET"
  printf "  %sq)%s Back\n\n" "$ORANGE" "$RESET"
  read -r -p "Choice: " ch
  case "$ch" in
    1) read -r -p "  New APK path: " newdir; [ -n "$newdir" ] || return 0; mkdir -p "$newdir" 2>/dev/null || true; if [ -d "$newdir" ]; then APKS_DIR="$newdir"; echo "Set."; else echo "Failed."; fi; read -r -p "Enter..." _ ;;
    2) if [ "$FANCY_UI" -eq 1 ]; then FANCY_UI=0; else FANCY_UI=1; fi; read -r -p "UI toggled. Press Enter..." _ ;;
  esac
}

# --------- Logs ---------
human_size() { local f="$1" s; [ -f "$f" ] || { echo "0B"; return; }; if du -h "$f" >/dev/null 2>&1; then du -h "$f" | awk '{print $1; exit}'; else s=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || wc -c < "$f" 2>/dev/null || echo 0); awk -v b="$s" 'function hum(x){s="BKMGTPE";i=1;while (x>=1024 && i<length(s)){x/=1024;i++} printf("%.1f%s", x, substr(s,i,1));} END{hum(b)}' <<< ""; fi; }
logs_view_recent() { enter_ui; banner_section "RECENT LOGS"; printf "%sFile: %s  Size: %s%s\n\n" "$DIM" "$LOG_FILE" "$(human_size "$LOG_FILE")" "$RESET"; if [ -s "$LOG_FILE" ]; then tail -n 200 "$LOG_FILE" 2>/dev/null || head -n 200 "$LOG_FILE" || true; else echo "(no log entries yet)"; fi; echo; read -r -p "Press Enter..." _; }
logs_follow_live() { enter_ui; banner_section "LIVE LOG FOLLOW"; printf "%sFile: %s%s\n\n" "$DIM" "$LOG_FILE" "$RESET"; if command -v less >/dev/null 2>&1; then less +F "$LOG_FILE"; else echo "Following log (Ctrl+C to stop)..."; tail -n 50 -f "$LOG_FILE"; fi; }
logs_export_downloads() { ensure_storage_ready; if [ ! -s "$LOG_FILE" ]; then banner; echo "No log file yet."; echo; read -r -p "Enter..." _; return 0; fi; local tmp base stamp; stamp="$(date '+%Y%m%d-%H%M%S')"; base="reinstall-$stamp.log"; tmp="$APP_DIR/$base"; cp -f "$LOG_FILE" "$tmp" 2>/dev/null || { banner; echo "Copy failed."; read -r -p "Enter..." _; return 1; }; publish_to_downloads_root "$tmp"; banner; echo "Exported to Downloads as: $base"; echo; read -r -p "Enter..." _; }
logs_clear() { enter_ui; banner; printf "Clear log file? This cannot be undone.\n\n"; read -r -p "Type YES to confirm: " ans; if [ "$ans" = "YES" ]; then : > "$LOG_FILE"; echo "Cleared."; else echo "Aborted."; fi; echo; read -r -p "Enter..." _; }
logs_collect_diag() {
  enter_ui
  banner_section "SYSTEM DIAGNOSTICS"
  local stamp out; stamp="$(date '+%Y%m%d-%H%M%S')"; out="$MS_DIR/diag-$stamp.txt"
  {
    echo "ReInstall Utility Diagnostics - $stamp"; echo "Version: $VERSION"; echo
    echo "System:"; uname -a 2>/dev/null || true; getprop ro.build.version.release 2>/dev/null | sed 's/^/Android: /' || true; getprop ro.product.manufacturer 2>/dev/null | sed 's/^/Manufacturer: /' || true; getprop ro.product.model 2>/dev/null | sed 's/^/Model: /' || true
    echo; echo "Paths:"; echo "HOME=$HOME"; echo "APKS_DIR=$APKS_DIR"; echo "MS_DIR=$MS_DIR"; echo "CONFIG_FILE=$CONFIG_FILE"; echo "LOG_FILE=$LOG_FILE"
    echo; echo "Binaries:"; for b in tsu pm am curl wget jq sha256sum openssl termux-open termux-media-scan termux-setup-storage less more gzip tmux screen; do printf "%-20s" "$b:"; command -v "$b" >/dev/null 2>&1 && printf " %s\n" "$(command -v "$b")" || echo " not found"; done
    echo; echo "Selection / Config:"; echo "- Built-in selected indices: $(read_config 2>/dev/null)"; echo "- Custom APKs (selected=1):"; custom_apks_selected_lines 2>/dev/null || true
    echo; echo "APK dir listing:"; ls -l "$APKS_DIR" 2>/dev/null || echo "(cannot list $APKS_DIR)"
    echo; echo "Latest log tail:"; tail -n 200 "$LOG_FILE" 2>/dev/null || echo "(no log)"
  } > "$out"
  echo "Saved: $out"; echo; read -r -p "Export to Downloads as well? (y/N): " ex; if [[ "$ex" =~ ^[Yy]$ ]]; then publish_to_downloads_root "$out"; echo "Exported."; fi; echo; read -r -p "Enter..." _; }
logs_menu() {
  while true; do
    enter_ui
    banner_section "LOG MANAGEMENT"
    printf "%sFile:%s %s\n" "$GRAY" "$RESET" "$LOG_FILE"
    printf "%sSize:%s %s\n\n" "$GRAY" "$RESET" "$(human_size "$LOG_FILE")"
    printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    printf "  %sV)%s View recent logs\n" "$ORANGE" "$RESET"
    printf "  %sF)%s Follow live\n" "$ORANGE" "$RESET"
    printf "  %sE)%s Export to Downloads\n" "$ORANGE" "$RESET"
    printf "  %sC)%s Clear log file\n" "$ORANGE" "$RESET"
    printf "  %sD)%s System diagnostics\n" "$ORANGE" "$RESET"
    printf "  %sQ)%s Back\n\n" "$ORANGE" "$RESET"
    read -r -p "Choice: " ch
    case "${ch:-}" in V|v) logs_view_recent ;; F|f) logs_follow_live ;; E|e) logs_export_downloads ;; C|c) logs_clear ;; D|d) logs_collect_diag ;; Q|q) break ;; *) echo "Invalid."; read -r -p "Enter..." _ ;; esac
  done
}

# --------- APK Management ---------
manage_custom_apks_menu() {
  while true; do
    enter_ui
    banner_section "CUSTOM GITHUB APKS"
    ensure_custom_file
    if [ -s "$CUSTOM_APKS_FILE" ]; then
      printf "%s%sConfigured APKs:%s\n\n" "$BOLD" "$WHITE" "$RESET"
      local i=0 cname curl csel
      while IFS=$'\t' read -r cname curl csel; do
        [ -z "${cname:-}${curl:-}${csel:-}" ] && continue
        i=$((i+1))
        printf "  %s%2d)%s %-36s %s[%s]%s %s%s%s\n" "$ORANGE" "$i" "$RESET" "$cname" "$DIM" "$([ "${csel:-0}" = "1" ] && echo "selected" || echo "off")" "$RESET" "$GRAY" "$curl" "$RESET"
      done < "$CUSTOM_APKS_FILE"
    else
      printf "%s(No custom APKs configured)%s\n" "$DIM" "$RESET"
    fi
    printf "\n%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    printf "  %sA)%s Add new APK\n" "$ORANGE" "$RESET"
    printf "  %sT)%s Toggle selection\n" "$ORANGE" "$RESET"
    printf "  %sR)%s Remove APK\n" "$ORANGE" "$RESET"
    printf "  %sQ)%s Back\n\n" "$ORANGE" "$RESET"
    read -r -p "Choice: " ch
    case "${ch:-}" in
      A|a)
        read -r -p "  Full asset URL (blank to build): " full
        if [ -n "$(trim "$full")" ]; then local nm; nm="$(basename "$full" 2>/dev/null || echo "custom.apk")"; read -r -p "  Name [$nm]: " nm2; nm2="${nm2:-$nm}"; custom_apks_add "$nm2" "$full" 1
        else read -r -p "  Owner: " owner; read -r -p "  Repo : " repo; read -r -p "  Tag  : " tag; read -r -p "  Asset: " asset; local u; u="$(build_github_release_url "$(trim "$owner")" "$(trim "$repo")" "$(trim "$tag")" "$(trim "$asset")")"; local nm; nm="$(basename "$u" 2>/dev/null || echo "custom.apk")"; custom_apks_add "$nm" "$u" 1; fi;;
      T|t) read -r -p "  Toggle number: " n; [[ "$n" =~ ^[0-9]+$ ]] && custom_apks_toggle "$n" ;;
      R|r) read -r -p "  Remove number: " n; [[ "$n" =~ ^[0-9]+$ ]] && custom_apks_remove "$n" ;;
      Q|q) break ;;
      *) echo "Invalid."; read -r -p "Enter..." _ ;;
    esac
  done
}

apk_menu() {
  while true; do
    enter_ui
    banner_section "APK MANAGEMENT"
    printf "%s%sOperations:%s\n\n" "$BOLD" "$WHITE" "$RESET"
    printf "  %s1)%s Continuous monitoring\n" "$ORANGE" "$RESET"
    printf "  %s2)%s Setup APK selection\n" "$ORANGE" "$RESET"
    printf "  %s3)%s Force download/reinstall\n" "$ORANGE" "$RESET"
    printf "  %s4)%s Manage custom APKs\n" "$ORANGE" "$RESET"
    printf "  %sq)%s Back to main menu\n\n" "$ORANGE" "$RESET"
    printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    read -r -p "Choice: " c
    case "$c" in
      1) start_monitor_from_menu ;;
      2) setup_reinstall ;;
      3) force_prompt_and_run ;;
      4) manage_custom_apks_menu ;;
      q|Q) break ;;
      "") continue ;;
      *) echo "Invalid."; read -r -p "Enter..." _ ;;
    esac
  done
}

# --------- Script Config ---------
script_config_menu() {
  while true; do
    enter_ui
    banner_section "SCRIPT CONFIGURATION"
    printf "%s%sFile Watchers:%s\n\n" "$BOLD" "$WHITE" "$RESET"
    printf "  %s1)%s Setup file watchers\n" "$ORANGE" "$RESET"
    printf "  %sq)%s Back to main menu\n\n" "$ORANGE" "$RESET"
    printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    read -r -p "Choice: " c
    case "$c" in 1) setup_watchers_menu ;; q|Q) break ;; "") continue ;; *) echo "Invalid."; read -r -p "Enter..." _ ;; esac
  done
}

setup_watchers_menu() {
  while true; do
    enter_ui
    banner_section "FILE WATCHERS SETUP"
    ensure_watchers_file
    if [ -s "$WATCHERS_FILE" ]; then
      printf "%s%sConfigured Watchers:%s\n\n" "$BOLD" "$WHITE" "$RESET"
      local i=0 wtgt wurl wen
      while IFS=$'\t' read -r wtgt wurl wen; do
        [ -z "${wtgt:-}${wurl:-}${wen:-}" ] && continue
        i=$((i+1))
        printf "  %s%2d)%s %-40s %s[%s]%s %s%s%s\n" "$ORANGE" "$i" "$RESET" "$wtgt" "$DIM" "$([ "${wen:-0}" = "1" ] && echo "on" || echo "off")" "$RESET" "$GRAY" "$wurl" "$RESET"
      done < "$WATCHERS_FILE"
    else printf "%s(No watchers configured)%s\n" "$DIM" "$RESET"; fi
    printf "\n%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    printf "  %sA)%s Add watcher\n" "$ORANGE" "$RESET"
    printf "  %sT)%s Toggle watcher\n" "$ORANGE" "$RESET"
    printf "  %sR)%s Remove watcher\n" "$ORANGE" "$RESET"
    printf "  %sQ)%s Back\n\n" "$ORANGE" "$RESET"
    read -r -p "Choice: " ch
    case "${ch:-}" in
      A|a)
        read -r -p "  Directory: " dir; dir="$(trim "$dir")"; [ -d "$dir" ] || { echo "  Not a dir."; read -r -p "Enter..." _; continue; }
        echo "  Type: 1=.json  2=.txt  3=.log  4=all"; read -r -p "  Pick: " tsel
        local pattern; case "$tsel" in 1)pattern="*.json";;2)pattern="*.txt";;3)pattern="*.log";;*)pattern="*.json *.txt *.log";; esac
        IFS=' ' read -r -a pat_arr <<< "$pattern"
        mapfile -t files < <( (shopt -s nullglob; for p in "${pat_arr[@]}"; do printf '%s\0' "$dir"/$p; done) | xargs -0 -n1 echo | sort )
        if [ "${#files[@]}" -gt 0 ]; then local j=0; for f in "${files[@]}"; do j=$((j+1)); printf "  %2d) %s\n" "$j" "$f"; done; fi
        read -r -p "  Number or full path: " pick
        local target; if [[ "$pick" =~ ^[0-9]+$ ]] && [ "$pick" -ge 1 ] && [ "$pick" -le "${#files[@]}" ]; then target="${files[$((pick-1))]}"; else target="$(trim "$pick")"; fi
        [ -n "$target" ] || { echo "  No file."; read -r -p "Enter..." _; continue; }
        [ -f "$target" ] || { mkdir -p "$(dirname "$target")"; : > "$target"; }
        read -r -p "  GitHub raw URL: " rawurl; rawurl="$(trim "$rawurl")"; [ -n "$rawurl" ] || { echo "  URL required."; read -r -p "Enter..." _; continue; }
        watchers_add "$target" "$rawurl" 1 ;;
      T|t) read -r -p "  Toggle number: " n; [[ "$n" =~ ^[0-9]+$ ]] && watchers_toggle "$n" ;;
      R|r) read -r -p "  Remove number: " n; [[ "$n" =~ ^[0-9]+$ ]] && watchers_remove "$n" ;;
      Q|q) break ;;
      *) echo "Invalid."; read -r -p "Enter..." _ ;;
    esac
  done
}

# --------- Boot & Autostart ---------
attach_to_session() {
  persist_read_env
  local sess="${TMUX_SESSION:-reinstall}"
  local mgr="${SESSION_MGR:-}"
  if [ -z "$mgr" ]; then
    if command -v tmux >/dev/null 2>&1; then mgr="tmux"
    elif command -v screen >/dev/null 2>&1; then mgr="screen"
    else mgr="none"; fi
  fi
  case "$mgr" in
    tmux)
      if command -v tmux >/dev/null 2>&1; then
        if tmux has-session -t "$sess" >/dev/null 2>&1; then tmux attach -t "$sess"; else echo "  tmux session '$sess' not found."; fi
      else echo "  tmux not installed."; fi ;;
    screen)
      if command -v screen >/dev/null 2>&1; then
        if screen -ls 2>/dev/null | grep -q "[[:space:]]\\.${sess}[[:space:]]"; then screen -r "$sess"; else echo "  screen session '$sess' not found."; fi
      else echo "  screen not installed."; fi ;;
    *) echo "  No session manager available." ;;
  esac
}

boot_autostart_menu() {
  while true; do
    enter_ui
    persist_read_env
    banner_section "BOOT & AUTOSTART"
    printf "%sCurrent status:%s\n" "$BOLD" "$RESET"
    printf "  %sAutostart:%s  %s\n" "$ORANGE" "$RESET" "$([ "${PERSIST_ENABLED:-0}" = "1" ] && echo "Enabled" || echo "Disabled")"
    printf "  %sMode:%s       %s\n" "$ORANGE" "$RESET" "${BOOT_MODE:-normal}"
    printf "  %sSession:%s    %s\n" "$ORANGE" "$RESET" "${TMUX_SESSION:-reinstall}"
    printf "  %sManager:%s    %s\n" "$ORANGE" "$RESET" "${SESSION_MGR:-auto}"
    printf "  %sInterval:%s   %ss\n" "$ORANGE" "$RESET" "${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}"
    printf "  %sAction:%s     %s\n\n" "$ORANGE" "$RESET" "${ACTION:-install}"

    printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    printf "  %s1)%s Enable Normal Boot (background)\n" "$ORANGE" "$RESET"
    printf "  %s2)%s Enable Session Boot (tmux/screen)\n" "$ORANGE" "$RESET"
    printf "  %s3)%s Start now (honor current settings)\n" "$ORANGE" "$RESET"
    printf "  %s4)%s Attach to session (if running)\n" "$ORANGE" "$RESET"
    printf "  %s5)%s Kill running monitor\n" "$ORANGE" "$RESET"
    printf "  %sD)%s Disable autostart\n" "$ORANGE" "$RESET"
    printf "  %sQ)%s Back\n\n" "$ORANGE" "$RESET"

    read -r -p "Choice: " ch
    case "${ch:-}" in
      1)
        local interval action
        read -r -p "  Interval seconds [${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}]: " interval; interval="${interval:-${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}}"
        echo "  Action: 1) install  2) download-only"
        read -r -p "  Pick [1/2]: " am; action="install"; [ "${am:-1}" = "2" ] && action="download"
        persist_write_env "${TMUX_SESSION:-reinstall}" "$interval" "$action" "$(script_self_path)" "normal" ""
        generate_watchdog; ensure_job_scheduler_watchdog; auto_setup_termux_boot
        echo "  Normal Boot enabled."
        read -r -p "Press Enter..." _ ;;
      2)
        local sess interval action mgr
        read -r -p "  Session name [${TMUX_SESSION:-reinstall}]: " sess; sess="${sess:-${TMUX_SESSION:-reinstall}}"
        read -r -p "  Interval seconds [${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}]: " interval; interval="${interval:-${INTERVAL:-$MONITOR_INTERVAL_DEFAULT}}"
        echo "  Manager: 1) tmux  2) screen"
        read -r -p "  Pick [1/2]: " pm; case "${pm:-1}" in 2) mgr="screen";; *) mgr="tmux";; esac
        echo "  Action: 1) install  2) download-only"
        read -r -p "  Pick [1/2]: " am; action="install"; [ "${am:-1}" = "2" ] && action="download"
        persist_write_env "$sess" "$interval" "$action" "$(script_self_path)" "session" "$mgr"
        generate_watchdog; ensure_job_scheduler_watchdog; auto_setup_termux_boot
        echo "  Session Boot enabled ($mgr session: $sess)."
        read -r -p "Start now and detach? (Y/n): " sn; if [[ ! "$sn" =~ ^[Nn]$ ]]; then "$WATCHDOG_SH"; echo "  Started."; fi
        read -r -p "Press Enter..." _ ;;
      3)
        [ -x "$WATCHDOG_SH" ] || generate_watchdog
        "$WATCHDOG_SH"
        echo "  Watchdog executed (start ensured)."
        read -r -p "Press Enter..." _ ;;
      4)
        attach_to_session
        read -r -p "Press Enter..." _ ;;
      5)
        kill_running_monitor
        read -r -p "Press Enter..." _ ;;
      D|d)
        persist_disable
        echo "  Autostart disabled."
        read -r -p "Press Enter..." _ ;;
      Q|q) break ;;
      *) echo "Invalid."; read -r -p "Press Enter..." _ ;;
    esac
  done
}

# --------- Init (ALT screen control) ---------
ensure_self_installed
auto_setup_termux_boot

ALTSCR_ACTIVE=0
enter_ui() {
  [ "$HAS_TTY" -eq 1 ] || return 0
  if [ "${ALTSCR_ACTIVE:-0}" -ne 1 ]; then
    ui_alt_on
    ALTSCR_ACTIVE=1
  fi
}
leave_ui() {
  if [ "${ALTSCR_ACTIVE:-0}" -eq 1 ]; then
    ui_show 2>/dev/null || true
    ui_alt_off 2>/dev/null || true
    ALTSCR_ACTIVE=0
  fi
}
cleanup() {
  if [ "${STATUS_INLINE:-0}" -eq 1 ]; then printf "\n"; STATUS_INLINE=0; fi
  leave_ui
}
trap cleanup EXIT

# --------- Main menu ---------
main_menu() {
  enter_ui
  while true; do
    banner
    printf "%s%sMAIN MENU%s\n\n" "$BOLD" "$WHITE" "$RESET"
    printf "  %s1)%s APK Management\n" "$ORANGE" "$RESET"
    printf "  %s2)%s Script Configuration\n" "$ORANGE" "$RESET"
    printf "  %s3)%s Log Management\n" "$ORANGE" "$RESET"
    printf "  %sb)%s Boot & Autostart\n" "$ORANGE" "$RESET"
    printf "  %ss)%s Settings\n" "$ORANGE" "$RESET"
    printf "  %sq)%s Quit\n\n" "$ORANGE" "$RESET"
    printf "%s────────────────────────────────────────%s\n\n" "$GRAY" "$RESET"
    read -r -p "Choice: " choice
    case "$choice" in
      1) apk_menu ;;
      2) script_config_menu ;;
      3) logs_menu ;;
      b|B) boot_autostart_menu ;;
      s|S) settings_menu ;;
      q|Q) echo; printf "%s%s✓ Goodbye%s\n" "$GREEN" "$BOLD" "$RESET"; return 0 ;;
      "") continue ;;
      *) echo "Invalid."; read -r -p "Enter..." _ ;;
    esac
  done
}

# --------- CLI ---------
INTERVAL_ARG=""; REPLACE_MODE="ask"
case "${1:-}" in
  --monitor)
    shift; NO_PROMPT=0
    while [ $# -gt 0 ]; do
      case "$1" in
        --no-prompt) NO_PROMPT=1; shift ;;
        --interval|-i) INTERVAL_ARG="${2:-}"; shift 2 ;;
        --download-only) CYCLE_APK_ACTION="download"; shift ;;
        --replace) REPLACE_MODE="replace"; shift ;;
        --keep) REPLACE_MODE="keep"; shift ;;
        *) shift ;;
      esac
    done
    if [ "${NO_PROMPT:-0}" -eq 1 ]; then monitor_loop "${INTERVAL_ARG:-$MONITOR_INTERVAL_DEFAULT}" "$REPLACE_MODE"; else start_monitor_from_menu; fi
    exit 0 ;;
  --force)      force_prompt_and_run; exit 0 ;;
  --force-download|D|d) process_table_once "download"; exit 0 ;;
  --force-di|DI|di)     process_table_once "install"; exit 0 ;;
  --setup)      setup_reinstall; exit 0 ;;
  --custom)     manage_custom_apks_menu; exit 0 ;;
  --watchers)   setup_watchers_menu; exit 0 ;;
  --check)      start_monitor_from_menu; exit 0 ;;
  --auto-check) monitor_loop "${MONITOR_INTERVAL_DEFAULT}" "replace"; exit 0 ;;
  --boot-setup) boot_autostart_menu; exit 0 ;;
  --enable-boot)
    shift
    MODE=""; SESS=""; INTV=""; ACT=""; MGR=""
    while [ $# -gt 0 ]; do
      case "$1" in
        normal|session) MODE="$1"; shift ;;
        --session) SESS="${2:-}"; shift 2 ;;
        --interval|-i) INTV="${2:-}"; shift 2 ;;
        --download-only) ACT="download"; shift ;;
        --install) ACT="install"; shift ;;
        --mgr|--manager) MGR="${2:-}"; shift 2 ;;
        *) break ;;
      esac
    done
    [ -z "$MODE" ] && MODE="normal"
    [ -z "$SESS" ] && SESS="reinstall"
    [ -z "$INTV" ] && INTV="$MONITOR_INTERVAL_DEFAULT"
    [ -z "$ACT" ] && ACT="install"
    [ -z "$MGR" ] && MGR=""
    persist_write_env "$SESS" "$INTV" "$ACT" "$(script_self_path)" "$MODE" "$MGR"
    generate_watchdog; ensure_job_scheduler_watchdog; auto_setup_termux_boot
    "$WATCHDOG_SH"
    exit 0 ;;
  --disable-boot) persist_disable; exit 0 ;;
  --help)
    echo "ReInstall Utility v$VERSION"
    echo "Main storage: $MS_DIR"
    echo "APKs dir   : $APKS_DIR"
    echo "Usage:"
    echo "  $0                           # menu (default)"
    echo "  $0 --monitor [--interval SECONDS] [--no-prompt] [--download-only] [--replace|--keep]"
    echo "  $0 --setup                   # select built-in APKs"
    echo "  $0 --custom                  # manage custom GitHub Release APKs"
    echo "  $0 --watchers                # configure file auto-update (raw GitHub)"
    echo "  $0 --force-download          # download all built-in + selected custom"
    echo "  $0 --force-di                # download+install all built-in + selected custom"
    echo "  $0 --boot-setup              # interactive Boot & Autostart menu"
    echo "  $0 --enable-boot [normal|session] [--session NAME] [--interval SECS] [--install|--download-only] [--mgr tmux|screen]"
    echo "  $0 --disable-boot            # disable autostart/watchdog"
    exit 0 ;;
esac

# --------- Interactive (default) ---------
main_menu
